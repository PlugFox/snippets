{
  "Main entry point": {
    "scope": "flutter, dart",
    "prefix": "main",
    "description": "Main entry point",
    "body": [
      "import 'dart:async';\n",
      "@pragma('vm:entry-point')",
      "void main([List<String>? args]) => runZonedGuarded<Future<void>>(() async {",
      "      ${0:// ...}",
      "    }, (error, stackTrace) {",
      "      //Error.safeToString(error);",
      "      //stackTrace.toString();",
      "      print('Error: $error, stackTrace: $stackTrace');",
      "    });\n"
    ]
  },
  "Try-catch-finally block": {
    "scope": "flutter, dart",
    "prefix": "try",
    "description": "Try-catch-finally block",
    "body": [
      "try {",
      "  // ...",
      "} on Object catch (error, stackTrace) {",
      "  Error.safeToString(error);",
      "  stackTrace.toString();",
      "  rethrow;",
      "} finally {",
      "  // ...",
      "}"
    ]
  },
  "Timeout handler": {
    "scope": "flutter, dart",
    "prefix": "timeout",
    "description": "Timeout handler",
    "body": "timeout(const Duration(milliseconds: 5000))${0:;}"
  },
  "Catch Error handler": {
    "scope": "flutter, dart",
    "prefix": [
      "catchError",
      "onError"
    ],
    "description": "Catch Error handler",
    "body": [
      "catchError(",
      "  (Object error, StackTrace stackTrace) => print(",
      "    Error.safeToString(error),",
      "  ),",
      "  test: (error) => error is TimeoutException,",
      ")${0:;}"
    ]
  },
  "Flow & Timeline example": {
    "scope": "flutter, dart",
    "prefix": [
      "flow",
      "timeline"
    ],
    "description": "Flow & Timeline example",
    "body": [
      "final flow = Flow.begin();",
      "Timeline.startSync('name', flow: flow);",
      "Timeline.instantSync('name');",
      "Timeline.finishSync();",
      "Flow.step(flow.id);",
      "final result = Timeline.timeSync<T>('name', () => null, flow: flow);",
      "Flow.end(flow.id);"
    ]
  },
  "Stopwatch": {
    "scope": "flutter, dart",
    "prefix": "stopwatch",
    "description": "Stopwatch",
    "body": [
      "final stopwatch = Stopwatch()..start();",
      "try {",
      "  /* ... */",
      "} finally {",
      "  log(",
      "    '${(stopwatch..stop()).elapsedMicroseconds} Î¼s',",
      "    name: 'select',",
      "    level: 100,",
      "  );",
      "}"
    ]
  },
  "Relieve event-loop": {
    "scope": "flutter, dart",
    "prefix": [
      "relieve",
      "discharge"
    ],
    "description": "Relieve event-loop",
    "body": [
      "/// Allow relieve impact on event loop on large collections.",
      "/// Parallelize the event queue and free up time for processing animation,",
      "/// user gestures without using isolates.",
      "Stream<${2}> ${1:relieve}(Iterable<${2:T}> iterable) async* {",
      "  final flow = Flow.begin();",
      "  final sw = Stopwatch()..start();",
      "  try {",
      "    final iter = iterable.iterator;",
      "    var i = 0;",
      "    Timeline.startSync('${1}#\\$i', flow: flow);",
      "    while (iter.moveNext()) {",
      "      if (sw.elapsed > const Duration(milliseconds: 4)) {",
      "        Timeline.finishSync();",
      "        await Future<void>.delayed(Duration.zero);",
      "        sw.reset();",
      "        i++;",
      "        Timeline.startSync('${1}#\\$i', flow: flow);",
      "      }",
      "      ${0}",
      "      yield iter.current;",
      "      Flow.step(flow.id);",
      "    }",
      "    Timeline.finishSync();",
      "    Flow.end(flow.id);",
      "  } finally {",
      "    sw.stop();",
      "  }",
      "}\n"
    ]
  },
  "Platform conditional imports": {
    "scope": "flutter, dart",
    "prefix": [
      "conditional_imports",
      "import_conditional"
    ],
    "description": "Platform conditional imports",
    "body": [
      "import 'stub.dart'",
      "    // ignore: uri_does_not_exist",
      "    if (dart.library.html) 'web.dart'",
      "    // ignore: uri_does_not_exist",
      "    if (dart.library.io) 'io.dart';\n"
    ]
  },
  "Changelog unreleased": {
    "scope": "md, markdown",
    "prefix": [
      "changelog_unreleased",
      "unreleased"
    ],
    "description": "Changelog unreleased",
    "body": [
      "## Unreleased",
      "",
      "- **ADDED**: ${0}",
      "- **CHANGED**: ",
      "- **DEPRECATED**: ",
      "- **REMOVED**: ",
      "- **FIXED**: ",
      "- **SECURITY**: ",
      "- **REFACTOR**: ",
      "- **DOCS**: ",
      "  "
    ]
  },
  "Changelog version": {
    "scope": "md, markdown",
    "prefix": [
      "changelog_version",
      "version"
    ],
    "description": "Changelog version section",
    "body": [
      "## ${1:0}.${2:0}.${3:0}",
      "",
      "- **ADDED**: ${0}",
      "- **CHANGED**: ",
      "- **DEPRECATED**: ",
      "- **REMOVED**: ",
      "- **FIXED**: ",
      "- **SECURITY**: ",
      "- **REFACTOR**: ",
      "- **DOCS**: ",
      "  "
    ]
  },
  "Comment": {
    "scope": "flutter, dart",
    "prefix": [
      "cmnt",
      "comment"
    ],
    "description": "Comment block",
    "body": "// --- ${1} --- //\n\n$0"
  },
  "Divider": {
    "scope": "flutter, dart",
    "prefix": [
      "dvd",
      "divider_comment"
    ],
    "description": "Divider comment line",
    "body": "// --- ${1} --- //\n\n$0"
  },
  "Enumeration": {
    "scope": "flutter, dart",
    "prefix": "enum",
    "description": "Create new enumeration",
    "body": [
      "/// {@template ${2:$TM_FILENAME_BASE}}",
      "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} enumeration",
      "/// {@endtemplate}",
      "enum ${1} implements Comparable<${1}> {",
      "  /// ${3}",
      "  ${3:a}('${3}'),",
      "",
      "  /// ${4}",
      "  ${4:b}('${4}'),",
      "",
      "  /// ${5}",
      "  ${5:c}('${5}');",
      "",
      "  /// {@macro ${2}}",
      "  const ${1}(this.value);${0}",
      "",
      "  /// Creates a new instance of [${1}] from a given string.",
      "  static ${1} fromValue(String? value, {${1}? fallback}) =>",
      "    switch (value?.trim().toLowerCase()) {",
      "      case '${3}' => ${3},",
      "      case '${4}' => ${4},",
      "      case '${5}' => ${5},",
      "      _ => fallback ?? (throw ArgumentError.value(value));",
      "    };",
      "",
      "  /// Value of the enum",
      "  final String value;",
      "",
      "  /// Pattern matching",
      "  T map<T>({",
      "    required T Function() ${3},",
      "    required T Function() ${4},",
      "    required T Function() ${5},",
      "  }) =>",
      "    switch (this) {",
      "      ${1}.${3} => ${3}(),",
      "      ${1}.${4} => ${4}(),",
      "      ${1}.${5} => ${5}(),",
      "    };",
      "",
      "  /// Pattern matching",
      "  T maybeMap<T>({",
      "    required T Function() orElse,",
      "    T Function()? ${3},",
      "    T Function()? ${4},",
      "    T Function()? ${5},",
      "  }) =>",
      "      map<T>(",
      "        ${3}: ${3} ?? orElse,",
      "        ${4}: ${4} ?? orElse,",
      "        ${5}: ${5} ?? orElse,",
      "      );",
      "",
      "  /// Pattern matching",
      "  T? maybeMapOrNull<T>({",
      "    T Function()? ${3},",
      "    T Function()? ${4},",
      "    T Function()? ${5},",
      "  }) =>",
      "      maybeMap<T?>(",
      "        orElse: () => null,",
      "        ${3}: ${3},",
      "        ${4}: ${4},",
      "        ${5}: ${5},",
      "      );",
      "",
      "  @override",
      "  int compareTo(${1} other) => index.compareTo(other.index);",
      "",
      "  @override",
      "  String toString() => value;",
      "}",
      ""
    ]
  },
  "Create new class": {
    "scope": "flutter, dart",
    "prefix": "class",
    "description": "Create new class",
    "body": [
      "/// {@template ${2:$TM_FILENAME_BASE}}",
      "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} class",
      "/// {@endtemplate}",
      "class ${1} {",
      "  /// {@macro ${2}}",
      "  const ${1}($0);",
      "  ",
      "}\n"
    ]
  },
  "Data class": {
    "scope": "flutter, dart",
    "prefix": [
      "entity",
      "dataClass",
      "classData"
    ],
    "description": "Create new class",
    "body": [
      "import 'package:meta/meta.dart';\n\n",
      "/// {@template ${2:$TM_FILENAME_BASE}}",
      "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} entity",
      "/// {@endtemplate}",
      "@immutable",
      "// ignore: prefer_mixin",
      "class ${1} with Comparable<${1}> {",
      "  /// {@macro ${2}}",
      "  ${1}({",
      "    required this.id,",
      "    required this.title,",
      "    this.description = '',",
      "    DateTime? updated,",
      "    DateTime? created,",
      "  })  : updated = updated ?? DateTime.now(),",
      "        created = created ?? updated ?? DateTime.now();${0}",
      "",
      "  /// The unique identifier for this object.",
      "  final int id;",
      "",
      "  /// The title of this object.",
      "  final String title;",
      "",
      "  /// A short description of this object.",
      "  final String description;",
      "",
      "  /// The date this object was last updated.",
      "  final DateTime updated;",
      "",
      "  /// The date this object was created.",
      "  final DateTime created;",
      "",
      "  /// Generate Class from Map<String, Object?>",
      "  factory ${1}.fromJson(Map<String, Object?> json) => ${1}(",
      "        id: (json['id'] as int?)!,",
      "        title: (json['title'] as String?)!,",
      "        description: (json['description'] as String?)!,",
      "        updated: DateTime.parse((json['updated'] as String?)!).toLocal(),",
      "        created: DateTime.parse((json['created'] as String?)!).toLocal(),",
      "      );",
      "",
      "  /// Generate Map<String, Object?> from class",
      "  @useResult",
      "  Map<String, Object?> toJson() => <String, Object?>{",
      "        'id': id,",
      "        'title': title,",
      "        'description': description,",
      "        'updated': updated.toUtc().toIso8601String(),",
      "        'created': created.toUtc().toIso8601String(),",
      "      };",
      "",
      "  /// Create a copy of this object with the given values.",
      "  @useResult",
      "  ${1} copyWith({",
      "    int? newId,",
      "    String? newTitle,",
      "    String? newDescription,",
      "    DateTime? newUpdated,",
      "    DateTime? newCreated,",
      "  }) =>",
      "      ${1}(",
      "        id: newId ?? id,",
      "        title: newTitle ?? title,",
      "        description: newDescription ?? description,",
      "        updated: newUpdated ?? DateTime.now(),",
      "        created: newCreated ?? created,",
      "      );",
      "",
      "  @override",
      "  int compareTo(${1} other) => id.compareTo(other.id);",
      "",
      "  @override",
      "  int get hashCode => id;",
      "",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      (other is ${1} && runtimeType == other.runtimeType && id == other.id);",
      "",
      "  @override",
      "  String toString() => '${1}#\\$id';",
      "",
      "}\n"
    ]
  },
  "Immutable collection data class": {
    "scope": "flutter, dart",
    "prefix": [
      "immutableCollection",
      "collectionDataClass"
    ],
    "description": "Immutable collection data class",
    "body": [
      "import 'dart:collection';\n",
      "import 'package:meta/meta.dart';\n\n",
      "/// {@template ${3:$TM_FILENAME_BASE}}",
      "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} immutable collection.",
      "/// Creates an unmodifiable list backed by source.",
      "///",
      "/// The source of the elements may be a [List] or any [Iterable] with",
      "/// efficient [Iterable.length] and [Iterable.elementAt].",
      "/// {@endtemplate}",
      "@immutable",
      "class ${1} extends IterableBase<${2:T}> {",
      "  /// {@macro ${3}}",
      "  ${1}(Iterable<${2}> source)",
      "      : _source = List<${2}>.of(source, growable: false);",
      "",
      "  /// {@macro ${3}}",
      "  /// Empty collection",
      "  const ${1}.empty() : _source = const Iterable.empty();",
      "",
      "  final Iterable<${2}> _source;",
      "",
      "  @override",
      "  int get length => _source.length;",
      "",
      "  @override",
      "  ${2} get last => _source.last;",
      "",
      "  @override",
      "  Iterator<${2}> get iterator => _source.iterator;",
      "",
      "  /// Adds [value] to the end of this list,",
      "  /// Returns a new list with the element added.",
      "  ${1} add(${2} value) =>",
      "      ${1}(List<${2}>.of(_source)..add(value));",
      "",
      "  /// Appends all objects of [iterable] to the end of this list.",
      "  /// Returns a new list with the elements added.",
      "  ${1} addAll(Iterable<${2}> iterable) =>",
      "      ${1}(List<${2}>.of(_source)..addAll(iterable));",
      "",
      "  /// Removes the first occurrence of [value] from this list.",
      "  /// Returns a new list with removed element.",
      "  ${1} remove(${2} value) => ${1}(",
      "        List<${2}>.of(_source)..remove(value),",
      "      );",
      "",
      "  /// Removes all objects from this list that satisfy [test].",
      "  /// Returns a new list with removed element.",
      "  ${1} removeWhere(bool Function(${2}) test) => ${1}(",
      "        List<${2}>.of(_source)..removeWhere(test),",
      "      );",
      "",
      "  /// Set element.",
      "  /// Returns a new list with element.",
      "  ${1} upsert(${2} element) => ${1}(",
      "        List<${2}>.of(_source)",
      "          ..remove(element)",
      "          ..add(element),",
      "      );",
      "",
      "  /// Sorts this list according to the order specified by the [compare] function",
      "  ${1} sort([int Function(${2} a, ${2} b)? compare]) => ${1}(",
      "        List<${2}>.of(_source, growable: false)..sort(compare),",
      "      );",
      "",
      "  /// Generate Map<String, Object?> from class",
      "  List<Map<String, Object?>> toJson() =>",
      "    _source.map<Map<String, Object?>>((e) => e.toJson()).toList();",
      "",
      "  /// Returns the element at the given [index] in the list",
      "  ///  or throws an [RangeError]",
      "  ${2} operator [](int index) => _source.elementAt(index);",
      "}\n"
    ]
  },
  "Reverse bypass": {
    "scope": "flutter, dart",
    "prefix": [
      "reverseList"
    ],
    "description": "Reverse list traversal in a loop",
    "body": [
      "for (var i = list.length - 1; i >= 0; i--) $0"
    ]
  },
  "Part": {
    "scope": "flutter, dart",
    "prefix": "part",
    "description": "Part of file",
    "body": [
      "part '${TM_FILENAME_BASE}.g.dart';$0"
    ]
  },
  "Mocks": {
    "scope": "flutter, dart",
    "prefix": "mocks",
    "description": "Import mocks file",
    "body": [
      "import '${TM_FILENAME_BASE}.mocks.dart';$0"
    ]
  },
  "Hash Code": {
    "scope": "flutter, dart",
    "prefix": [
      "hashCode",
      "equals",
      "=="
    ],
    "description": "Hash Code and Equals override",
    "body": [
      "@override",
      "int get hashCode => id.hashCode;\n",
      "@override",
      "bool operator ==(Object other) =>",
      "    identical(this, other) ||",
      "    other is ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} &&",
      "        runtimeType == other.runtimeType &&",
      "        id == other.id;${0}\n"
    ]
  },
  "BLoC Events": {
    "scope": "flutter, dart",
    "prefix": [
      "events",
      "bloc_events",
      "BLoC_Events"
    ],
    "description": "Buisness Logic Component Events",
    "body": [
      "part of '${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(_event)/${1}${2}/g}_bloc.dart';\n",
      "/// Business Logic Component ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}} Events",
      "@freezed",
      "class ${1}Event with _$${1}Event {",
      "  const ${1}Event._();\n",
      "  /// Create",
      "  const factory ${1}Event.create({required ItemData itemData}) = Create${1}Event;\n",
      "  /// Fetch",
      "  const factory ${1}Event.fetch({required int id}) = Fetch${1}Event;\n",
      "  /// Update",
      "  const factory ${1}Event.update({required Item item}) = Update${1}Event;\n",
      "  /// Delete",
      "  const factory ${1}Event.delete({required Item item}) = Delete${1}Event;\n",
      "}\n"
    ]
  },
  "States": {
    "scope": "flutter, dart",
    "prefix": [
      "states",
      "bloc_states",
      "BLoC_States"
    ],
    "description": "States",
    "body": [
      "import 'package:meta/meta.dart';",
      "",
      "/// {@template ${1:$TM_FILENAME_BASE}_placeholder}",
      "/// Entity placeholder for ${2:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(state)/${1:/upcase}${2:/camelcase}/g}}State",
      "/// {@endtemplate}",
      "typedef ${2}Entity = Object;",
      "",
      "/// {@template ${1}}",
      "/// ${2}State.",
      "/// {@endtemplate}",
      "sealed class ${2}State extends _\\$${2}StateBase {",
      "  /// Idling state",
      "  /// {@macro ${1}}",
      "  const factory ${2}State.idle({",
      "    required ${2}Entity? data,",
      "    String message,",
      "  }) = ${2}State\\$Idle;\n",
      "  /// Processing",
      "  /// {@macro ${1}}",
      "  const factory ${2}State.processing({",
      "    required ${2}Entity? data,",
      "    String message,",
      "  }) = ${2}State\\$Processing;\n",
      "  /// Successful",
      "  /// {@macro ${1}}",
      "  const factory ${2}State.successful({",
      "    required ${2}Entity? data,",
      "    String message,",
      "  }) = ${2}State\\$Successful;\n",
      "  /// An error has occurred",
      "  /// {@macro ${1}}",
      "  const factory ${2}State.error({",
      "    required ${2}Entity? data,",
      "    String message,",
      "  }) = ${2}State\\$Error;\n${0}",
      "  /// {@macro ${1}}",
      "  const ${2}State({required super.data, required super.message});",
      "}\n",
      "/// Idling state",
      "/// {@nodoc}",
      "final class ${2}State\\$Idle extends ${2}State  {",
      "  /// {@nodoc}",
      "  const ${2}State\\$Idle({required super.data, super.message = 'Idling'});",
      "}\n",
      "/// Processing",
      "/// {@nodoc}",
      "final class ${2}State\\$Processing extends ${2}State  {",
      "  /// {@nodoc}",
      "  const ${2}State\\$Processing({required super.data, super.message = 'Processing'});",
      "}\n",
      "/// Successful",
      "/// {@nodoc}",
      "final class ${2}State\\$Successful extends ${2}State  {",
      "  /// {@nodoc}",
      "  const ${2}State\\$Successful({required super.data, super.message = 'Successful'});",
      "}\n",
      "/// Error",
      "/// {@nodoc}",
      "final class ${2}State\\$Error extends ${2}State  {",
      "  /// {@nodoc}",
      "  const ${2}State\\$Error({required super.data, super.message = 'An error has occurred.'});",
      "}\n",
      "/// Pattern matching for [${2}State].",
      "typedef ${2}StateMatch<R, S extends ${2}State> = R Function(S state);\n",
      "/// {@nodoc}",
      "@immutable",
      "abstract base class _\\$${2}StateBase {",
      "  /// {@nodoc}",
      "  const _\\$${2}StateBase({required this.data, required this.message});\n",
      "  /// Data entity payload.",
      "  @nonVirtual",
      "  final ${2}Entity? data;\n",
      "  /// Message or state description.",
      "  @nonVirtual",
      "  final String message;\n",
      "  /// Has data?",
      "  bool get hasData => data != null;\n",
      "  /// If an error has occurred?",
      "  bool get hasError => maybeMap<bool>(orElse: () => false, error: (_) => true);\n",
      "  /// Is in progress state?",
      "  bool get isProcessing => maybeMap<bool>(orElse: () => false, processing: (_) => true);\n",
      "  /// Is in idle state?",
      "  bool get isIdling => !isProcessing;\n",
      "  /// Pattern matching for [${2}State].",
      "  R map<R>({",
      "    required ${2}StateMatch<R, ${2}State\\$Idle> idle,",
      "    required ${2}StateMatch<R, ${2}State\\$Processing> processing,",
      "    required ${2}StateMatch<R, ${2}State\\$Successful> successful,",
      "    required ${2}StateMatch<R, ${2}State\\$Error> error,",
      "  }) =>",
      "      switch (this) {",
      "        ${2}State\\$Idle s => idle(s),",
      "        ${2}State\\$Processing s => processing(s),",
      "        ${2}State\\$Successful s => successful(s),",
      "        ${2}State\\$Error s => error(s),",
      "        _ => throw AssertionError(),",
      "      };\n",
      "  /// Pattern matching for [${2}State].",
      "  R maybeMap<R>({",
      "    ${2}StateMatch<R, ${2}State\\$Idle>? idle,",
      "    ${2}StateMatch<R, ${2}State\\$Processing>? processing,",
      "    ${2}StateMatch<R, ${2}State\\$Successful>? successful,",
      "    ${2}StateMatch<R, ${2}State\\$Error>? error,",
      "    required R Function() orElse,",
      "  }) =>",
      "      map<R>(",
      "        idle: idle ?? (_) => orElse(),",
      "        processing: processing ?? (_) => orElse(),",
      "        successful: successful ?? (_) => orElse(),",
      "        error: error ?? (_) => orElse(),",
      "      );\n",
      "  /// Pattern matching for [${2}State].",
      "  R? mapOrNull<R>({",
      "    ${2}StateMatch<R, ${2}State\\$Idle>? idle,",
      "    ${2}StateMatch<R, ${2}State\\$Processing>? processing,",
      "    ${2}StateMatch<R, ${2}State\\$Successful>? successful,",
      "    ${2}StateMatch<R, ${2}State\\$Error>? error,",
      "  }) =>",
      "      map<R?>(",
      "        idle: idle ?? (_) => null,",
      "        processing: processing ?? (_) => null,",
      "        successful: successful ?? (_) => null,",
      "        error: error ?? (_) => null,",
      "      );\n",
      "  @override",
      "  int get hashCode => data.hashCode;\n",
      "  @override",
      "  bool operator ==(Object other) => identical(this, other);",
      "",
      "  @override",
      "  String toString() => '${2}State(data: \\$data, message: \\$message)';",
      "}\n"
    ]
  },
  "BLoC": {
    "scope": "flutter, dart",
    "prefix": [
      "bloc",
      "BLoC"
    ],
    "description": "Buisness Logic Component",
    "body": [
      "import 'dart:async';\n",
      "import 'package:bloc/bloc.dart';",
      "import 'package:bloc_concurrency/bloc_concurrency.dart' as bloc_concurrency;",
      "import 'package:freezed_annotation/freezed_annotation.dart';\n",
      "part '${TM_FILENAME_BASE}.freezed.dart';",
      "part '${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(_bloc)/${1}${2}/g}_event.dart';",
      "part '${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(_bloc)/${1}${2}/g}_state.dart';\n",
      "/// Business Logic Component ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}}BLoC",
      "class ${1}BLoC extends Bloc<${1}Event, ${1}State> implements EventSink<${1}Event> {",
      "  ${1}BLoC({",
      "    required final I${1}Repository repository,",
      "    final ${1}State? initialState,",
      "  }) : _repository = repository,",
      "        super(",
      "          initialState ??",
      "              ${1}State.idle(",
      "                data: ${1}Entity(),",
      "                message: 'Initial idle state',",
      "              ),",
      "        ) {",
      "    on<${1}Event>(",
      "      (event, emit) => event.map<Future<void>>(",
      "        fetch: (event) => _fetch(event, emit),",
      "      ),",
      "      transformer: bloc_concurrency.sequential(),",
      "      //transformer: bloc_concurrency.restartable(),",
      "      //transformer: bloc_concurrency.droppable(),",
      "      //transformer: bloc_concurrency.concurrent(),",
      "    );$0",
      "  }",
      "  ",
      "  final I${1}Repository _repository;",
      "  ",
      "  /// Fetch event handler",
      "  Future<void> _fetch(Fetch${1}Event event, Emitter<${1}State> emit) async {",
      "    try {",
      "      emit(${1}State.processing(data: state.data));",
      "      final newData = await _repository.fetch(event.id);",
      "      emit(${1}State.successful(data: newData));",
      "    } on Object catch (err, stackTrace) {",
      "      //l.e('An error occurred in the ${1}BLoC: \\$err', stackTrace);",
      "      emit(${1}State.error(data: state.data));",
      "      rethrow;",
      "    } finally {",
      "      emit(${1}State.idle(data: state.data));",
      "    }",
      "  }",
      "}\n"
    ]
  },
  "BLoC Extended": {
    "scope": "flutter, dart",
    "prefix": "blocExtended",
    "description": "Buisness Logic Component with mixins",
    "body": [
      "import 'dart:async';\n",
      "import 'package:bloc/bloc.dart';",
      "import 'package:bloc_concurrency/bloc_concurrency.dart' as bloc_concurrency;",
      "import 'package:freezed_annotation/freezed_annotation.dart';",
      "import 'package:l/l.dart';\n",
      "part '${TM_FILENAME_BASE}.freezed.dart';\n",
      "/* ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}} Events */\n",
      "@freezed",
      "class ${1}Event with _$${1}Event {",
      "  const ${1}Event._();\n",
      "  @Implements<I${1}Event>()",
      "  @With<_ProcessingStateEmitter>()",
      "  @With<_SuccessfulStateEmitter>()",
      "  @With<_ErrorStateEmitter>()",
      "  @With<_IdleStateEmitter>()",
      "  const factory ${1}Event.create() = Create${1}Event;\n",
      "  @Implements<I${1}Event>()",
      "  @With<_ProcessingStateEmitter>()",
      "  @With<_SuccessfulStateEmitter>()",
      "  @With<_ErrorStateEmitter>()",
      "  @With<_IdleStateEmitter>()",
      "  const factory ${1}Event.read() = Read${1}Event;\n",
      "  @Implements<I${1}Event>()",
      "  @With<_ProcessingStateEmitter>()",
      "  @With<_SuccessfulStateEmitter>()",
      "  @With<_ErrorStateEmitter>()",
      "  @With<_IdleStateEmitter>()",
      "  const factory ${1}Event.update() = Update${1}Event;\n",
      "  @Implements<I${1}Event>()",
      "  @With<_ProcessingStateEmitter>()",
      "  @With<_SuccessfulStateEmitter>()",
      "  @With<_ErrorStateEmitter>()",
      "  @With<_IdleStateEmitter>()",
      "  const factory ${1}Event.delete() = Delete${1}Event;",
      "}\n",
      "/* ${1} States */\n",
      "@freezed",
      "class ${1}State with _$${1}State {",
      "  const ${1}State._();\n",
      "  /// Is in idle state",
      "  bool get idling => !isProcessing;\n",
      "  /// Is in progress state",
      "  bool get isProcessing => maybeMap<bool>(",
      "        orElse: () => true,",
      "        idle: (_) => false,",
      "      );\n",
      "  /// If an error has occurred",
      "  bool get hasError => maybeMap<bool>(orElse: () => false, error: (_) => true);\n",
      "  /// Idling state",
      "  const factory ${1}State.idle({",
      "    required final ${1}Entity data,",
      "    @Default('Idle') final String message,",
      "  }) = Idle${1}State;\n",
      "  /// Processing",
      "  const factory ${1}State.processing({",
      "    required final ${1}Entity data,",
      "    @Default('Processing') final String message,",
      "  }) = Processing${1}State;\n",
      "  /// Successful",
      "  const factory ${1}State.successful({",
      "    required final ${1}Entity data,",
      "    @Default('Successful') final String message,",
      "  }) = Successful${1}State;\n",
      "  /// An error has occurred",
      "  const factory ${1}State.error({",
      "    required final ${1}Entity data,",
      "    @Default('An error has occurred') final String message,",
      "  }) = Error${1}State;",
      "}\n",
      "/// Business Logic Component ${1}BLoC",
      "class ${1}BLoC extends Bloc<${1}Event, ${1}State> implements EventSink<${1}Event> {",
      "  ${1}BLoC({",
      "    required final I${1}Repository repository,",
      "    final ${1}State? initialState,",
      "  }) : _repository = repository,",
      "        super(",
      "          initialState ??",
      "              ${1}State.idle(",
      "                data: ${1}Entity(),",
      "                message: 'Initial idle state',",
      "              ),",
      "        ) {",
      "    on<${1}Event>(",
      "      (event, emit) => event.map<Future<void>>(",
      "        create: (event) => _create(event, emit),",
      "        read: (event) => _read(event, emit),",
      "        update: (event) => _update(event, emit),",
      "        delete: (event) => _delete(event, emit),",
      "      ),",
      "      transformer: bloc_concurrency.sequential(),",
      "      //transformer: bloc_concurrency.restartable(),",
      "      //transformer: bloc_concurrency.droppable(),",
      "      //transformer: bloc_concurrency.concurrent(),",
      "    );$0",
      "  }",
      "  ",
      "  final I${1}Repository _repository;",
      "  ",
      "  /// Create event handler",
      "  Future<void> _create(Create${1}Event event, Emitter<${1}State> emit) async {",
      "    try {",
      "      emit(event.inProgress(state: state));",
      "      //final newData = await _repository.();",
      "      emit(event.successful(state: state, newData: newData));",
      "    } on Object catch (err, stackTrace) {",
      "      l.e('An error occurred in the ${1}BLoC: \\$err', stackTrace);",
      "      emit(event.error(state: state, message: 'An error occurred'));",
      "      rethrow;",
      "    } finally {",
      "      emit(event.idle(state: state));",
      "    }",
      "  }",
      "  ",
      "  /// Read event handler",
      "  Future<void> _read(Read${1}Event event, Emitter<${1}State> emit) async {",
      "    try {",
      "      emit(event.inProgress(state: state));",
      "      //final newData = await _repository.();",
      "      emit(event.successful(state: state, newData: newData));",
      "    } on Object catch (err, stackTrace) {",
      "      l.e('An error occurred in the ${1}BLoC: \\$err', stackTrace);",
      "      emit(event.error(state: state, message: 'An error occurred'));",
      "      rethrow;",
      "    } finally {",
      "      emit(event.idle(state: state));",
      "    }",
      "  }",
      "  ",
      "  /// Update event handler",
      "  Future<void> _update(Update${1}Event event, Emitter<${1}State> emit) async {",
      "    try {",
      "      emit(event.inProgress(state: state));",
      "      //final newData = await _repository.();",
      "      emit(event.successful(state: state, newData: newData));",
      "    } on Object catch (err, stackTrace) {",
      "      l.e('An error occurred in the ${1}BLoC: \\$err', stackTrace);",
      "      emit(event.error(state: state, message: 'An error occurred'));",
      "      rethrow;",
      "    } finally {",
      "      emit(event.idle(state: state));",
      "    }",
      "  }",
      "  ",
      "  /// Delete event handler",
      "  Future<void> _delete(Delete${1}Event event, Emitter<${1}State> emit) async {",
      "    try {",
      "      emit(event.inProgress(state: state));",
      "      //final newData = await _repository.();",
      "      emit(event.successful(state: state, newData: newData));",
      "    } on Object catch (err, stackTrace) {",
      "      l.e('An error occurred in the ${1}BLoC: \\$err', stackTrace);",
      "      emit(event.error(state: state, message: 'An error occurred'));",
      "      rethrow;",
      "    } finally {",
      "      emit(event.idle(state: state));",
      "    }",
      "  }",
      "}",
      "",
      "/* ÐÐ½ÑÐµÑÑÐµÐ¹ÑÑ Ð´Ð»Ñ ÑÐ²ÐµÐ½ÑÐ¾Ð² ${1}Event */",
      "",
      "abstract class I${1}Event {}",
      "",
      "/* ÐÐ¸ÐºÑÐ¸Ð½Ñ Ð´Ð»Ñ ÑÐ²ÐµÐ½ÑÐ¾Ð² ${1}Event */",
      "",
      "/// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹ \"Ð² Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐµ\"",
      "mixin _ProcessingStateEmitter on ${1}Event {",
      "  /// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ \"Ð² Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐµ\"",
      "  ${1}State inProgress({",
      "    required final ${1}State state,",
      "    final String? message,",
      "  }) =>",
      "      ${1}State.processing(",
      "        data: state.data,",
      "        message: message ?? 'Processing',",
      "      );",
      "}",
      "",
      "/// ÐÑÐ¿ÑÑÐº ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ ÑÑÐ¿ÐµÑÐ½Ð¾Ð¹ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸",
      "mixin _SuccessfulStateEmitter on ${1}Event {",
      "  /// ÐÑÐ¿ÑÑÐº ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ ÑÑÐ¿ÐµÑÐ½Ð¾Ð¹ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸",
      "  ${1}State successful({",
      "    required final ${1}State state,",
      "    final ${1}Entity? newData,",
      "    final String? message,",
      "  }) =>",
      "      ${1}State.successful(",
      "        data: newData ?? state.data,",
      "        message: message ?? 'Successful',",
      "      );",
      "}",
      "",
      "/// ÐÑÐ¿ÑÑÐº ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ Ð¾ÑÐ¸Ð±ÐºÐ¸",
      "mixin _ErrorStateEmitter on ${1}Event {",
      "  /// An error occurred",
      "  ${1}State error({",
      "    required final ${1}State state,",
      "    final String? message,",
      "  }) =>",
      "      ${1}State.error(",
      "        data: state.data,",
      "        message: message ?? 'An error has occurred',",
      "      );",
      "}",
      "",
      "/// Ð¡Ð¾ÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ð¹ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ",
      "mixin _IdleStateEmitter on ${1}Event {",
      "  /// Ð¡Ð¾ÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ð¹ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ",
      "  /// ÐÑÐ¾ÑÑÐ°Ð¸Ð²Ð°ÐµÐ¼ Ð´Ð¾ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐ¾Ð±ÑÑÐ¸Ñ",
      "  ${1}State idle({",
      "    required final ${1}State state,",
      "    final String? message,",
      "  }) =>",
      "      ${1}State.idle(",
      "        data: state.data,",
      "        message: message ?? 'Idle',",
      "      );",
      "}"
    ]
  },
  "BLoC Test": {
    "scope": "flutter, dart",
    "prefix": "blocTest",
    "description": "Buisness Logic Component Test",
    "body": [
      "blocTest<${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}}BLoC, ${1}State>(",
      "  '${1}BLoC',",
      "  setUp: () async {},",
      "  tearDown: null,",
      "  build: () => ${1}BLoC(),",
      "  seed: () => ${1}State.idle(),",
      "  act: (bloc) => bloc.add(${1}Event.event()),",
      "  wait: const Duration(milliseconds: 150),",
      "  skip: 0,",
      "  expect: () => <Object>[",
      "    ${1}State.processing(),",
      "    ${1}State.idle(),",
      "  ],",
      "  verify: null,",
      "  errors: null,",
      ");"
    ]
  },
  "Freezed": {
    "scope": "flutter, dart",
    "prefix": [
      "freezed",
      "freezed_v1"
    ],
    "description": "Freezed data class",
    "body": [
      "import 'package:freezed_annotation/freezed_annotation.dart';",
      "",
      "part '${TM_FILENAME_BASE}.freezed.dart';",
      "part '${TM_FILENAME_BASE}.g.dart';",
      "",
      "/// ${1} data class",
      "@freezed",
      "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} with _$${1} {",
      "  const factory ${1}({",
      "    @JsonKey(name: 'value', required: true, disallowNullValue: true)",
      "      required final String value,",
      "  }) = _${1};",
      "  ${0}",
      "  const ${1}._();",
      "",
      "  /// Generate ${1} class from Map<String, Object?>",
      "  factory ${1}.fromJson(Map<String, Object?> json) => _$${1}FromJson(json);",
      "}"
    ]
  },
  "Freezed union": {
    "scope": "flutter, dart",
    "prefix": [
      "freezed_union",
      "freezed_union_v1"
    ],
    "description": "Freezed union data classes",
    "body": [
      "// ignore_for_file: invalid_annotation_target",
      "",
      "import 'package:freezed_annotation/freezed_annotation.dart';",
      "",
      "part '${TM_FILENAME_BASE}.freezed.dart';",
      "part '${TM_FILENAME_BASE}.g.dart';",
      "",
      "/// ${1} data class",
      "@Freezed(unionKey: 'type', unionValueCase: FreezedUnionCase.snake)",
      "sealed class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} with _$${1} {",
      "  const ${1}._();",
      "",
      "  /// ${1}\\$Idle",
      "  @FreezedUnionValue('IDLE')",
      "  const factory ${1}.idle({",
      "    @JsonKey(name: 'data', required: true, disallowNullValue: true)",
      "      required final String data,",
      "    @JsonKey(name: 'message', required: false) @Default('Idling.') String message,",
      "  }) = ${1}\\$Idle;",
      "",
      "  /// ${1}\\$Processing",
      "  @FreezedUnionValue('PROCESSING')",
      "  const factory ${1}.processing({",
      "    @JsonKey(name: 'data', required: true, disallowNullValue: true) required final String data,",
      "    @JsonKey(name: 'message', required: false) @Default('Processing.') String message,",
      "  }) = ${1}\\$Processing;",
      "",
      "  /// ${1}\\$Successful",
      "  @FreezedUnionValue('SUCCESSFUL')",
      "  const factory ${1}.successful({",
      "    @JsonKey(name: 'data', required: true, disallowNullValue: true) required final String data,",
      "    @JsonKey(name: 'message', required: false) @Default('Successful.') String message,",
      "  }) = ${1}\\$Successful;",
      "",
      "  /// ${1}\\$Error",
      "  @FreezedUnionValue('ERROR')",
      "  const factory ${1}.error({",
      "    @JsonKey(name: 'data', required: true, disallowNullValue: true) required final String data,",
      "    @JsonKey(name: 'message', required: false) @Default('An error has occurred.') String message,",
      "  }) = ${1}\\$Error;",
      "  ${0}",
      "  /// Generate ${1} class from Map<String, Object?>",
      "  factory ${1}.fromJson(Map<String, Object?> json) => _$${1}FromJson(json);",
      "}"
    ]
  },
  "JSON": {
    "scope": "flutter, dart",
    "prefix": [
      "json",
      "fromJson",
      "toJson"
    ],
    "description": "Generate JSON",
    "body": [
      "/// Generate Class from Map<String, Object?>",
      "factory ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}}.fromJson(Map<String, Object?> json) => _$${1}FromJson(json);",
      "",
      "/// Generate Map<String, Object?> from class",
      "Map<String, Object?> toJson() => _$${1}ToJson(this);"
    ]
  },
  "Fake": {
    "scope": "flutter, dart",
    "prefix": "fake",
    "description": "Generate Fake class",
    "body": [
      "class Mock${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} extends Fake implements ${1} {}"
    ]
  },
  /* Other snippets */
  "Singleton": {
    "scope": "flutter, dart",
    "prefix": "singleton",
    "description": "Create a singleton class in Dart",
    "body": [
      "/// ${1} Singleton class",
      "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} {",
      "  static final ${1} _internalSingleton = ${1}._internal();",
      "  factory ${1}() => _internalSingleton;",
      "  ${1}._internal();\n",
      "  ${0}",
      "}"
    ]
  },
  "StreamTransformer with handlers": {
    "scope": "flutter, dart",
    "prefix": [
      "transformer_handlers",
      "stream_transformer_handlers"
    ],
    "description": "StreamTransformer with handlers, convert types",
    "body": [
      "import 'dart:async';\n",
      "import 'package:meta/meta.dart';\n",
      "/// ${1} extension methods.",
      "/// sourceStream.${1/(.)(.*)/${1:/downcase}$2/g}<T>()",
      "extension ${1}X<Input> on Stream<Input> {",
      "  /// {@macro ${2}}",
      "  Stream<Output> ${1/(.)(.*)/${1:/downcase}$2/g}<Output>({",
      "    /// Handler for the stream data channel.",
      "    required FutureOr<void> Function(",
      "      Input data,",
      "      EventSink<Output> sink,",
      "    )",
      "        handleData,",
      "",
      "    /// Handler for the stream error channel.",
      "    FutureOr<void> Function(",
      "      Object error,",
      "      StackTrace stackTrace,",
      "      EventSink<Output> sink,",
      "    )?",
      "        handleError,",
      "",
      "    /// Handler for the stream close event.",
      "    FutureOr<void> Function(",
      "      EventSink<Output> sink,",
      "    )?",
      "        handleDone,",
      "}) =>",
      "    transform<Output>(",
      "        ${1}<Input, Output>(",
      "          handleData: handleData,",
      "          handleError: handleError,",
      "          handleDone: handleDone,",
      "        ),",
      "      );",
      "}\n",
      "/// {@template ${2:$TM_FILENAME_BASE}}",
      "/// ${1} stream transformer",
      "/// {@endtemplate}",
      "@immutable",
      "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}}<Input, Output>",
      "    extends StreamTransformerBase<Input, Output> {",
      "  /// {@macro ${2}}",
      "  const ${1}({",
      "    required this.handleData,",
      "    this.handleError,",
      "    this.handleDone,",
      "  });",
      "",
      "  final FutureOr<void> Function(",
      "    Input data,",
      "    EventSink<Output> sink,",
      "  ) handleData;",
      "",
      "  final FutureOr<void> Function(",
      "    Object error,",
      "    StackTrace stackTrace,",
      "    EventSink<Output> sink,",
      "  )? handleError;",
      "",
      "  final FutureOr<void> Function(EventSink<Output> sink)? handleDone;",
      "",
      "  @override",
      "  Stream<Output> bind(Stream<Input> stream) {",
      "    final controller = stream.isBroadcast",
      "        ? StreamController<Output>.broadcast(sync: true)",
      "        : StreamController<Output>(sync: true);",
      "    return (controller..onListen = () => _onListen(stream, controller)).stream;",
      "  }",
      "",
      "  void _onListen(",
      "    Stream<Input> stream,",
      "    StreamController<Output> controller,",
      "  ) {",
      "    final sink = controller.sink;",
      "    final subscription = stream.listen(null, cancelOnError: false);",
      "    controller.onCancel = subscription.cancel;",
      "    if (!stream.isBroadcast) {",
      "      controller",
      "        ..onPause = subscription.pause",
      "        ..onResume = subscription.resume;",
      "    }",
      "    final scaffold = _scaffold(sink, subscription.pause, subscription.resume);",
      "    subscription",
      "      ..onData(",
      "        (Input data) => scaffold(() => handleData(data, sink)),",
      "      )",
      "      ..onError(",
      "        (Object error, StackTrace stackTrace) => handleError == null",
      "            ? sink.addError(error, stackTrace)",
      "            : scaffold(() => handleError!(error, stackTrace, sink)),",
      "      )",
      "      ..onDone(",
      "        () => handleDone == null",
      "            ? sink.close()",
      "            : scaffold(() => handleDone!(sink)).whenComplete(sink.close),",
      "      );",
      "  }",
      "",
      "  Future<void> Function(FutureOr<void> Function() handler) _scaffold(",
      "    StreamSink<Output> sink,",
      "    void Function([Future<void>? resumeSignal]) pause,",
      "    void Function() resume,",
      "  ) =>",
      "      (FutureOr<void> Function() handler) {",
      "        ${0:// PUT YOUR CODE HERE}",
      "        FutureOr<void> fn;",
      "        try {",
      "          fn = handler();",
      "        } on Object catch (error, stackTrace) {",
      "          sink.addError(error, stackTrace);",
      "        }",
      "        if (fn is Future) {",
      "          pause();",
      "          return fn.catchError(sink.addError).whenComplete(resume);",
      "        } else {",
      "          return Future<void>.value();",
      "        }",
      "      };",
      "}\n"
    ]
  },
  "StreamTransformer with control queue delay": {
    "scope": "flutter, dart",
    "prefix": [
      "transformer_delay",
      "stream_transformer_delay"
    ],
    "description": "StreamTransformer with control queue delay",
    "body": [
      "import 'dart:async';\n",
      "import 'package:meta/meta.dart';\n",
      "/// ${1} extension methods.",
      "/// sourceStream.${1/(.)(.*)/${1:/downcase}$2/g}<T>()",
      "extension ${1}X<T> on Stream<T> {",
      "  /// {@macro ${2}}",
      "  Stream<T> ${1/(.)(.*)/${1:/downcase}$2/g}(Duration duration) =>",
      "      transform<T>(${1}<T>(duration));",
      "}\n",
      "/// {@template ${2:$TM_FILENAME_BASE}}",
      "/// ${1} stream transformer",
      "/// {@endtemplate}",
      "@immutable",
      "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}}<T>",
      "    extends StreamTransformerBase<T, T> {",
      "  /// {@macro ${2}}",
      "  const ${1}(this.duration);",
      "",
      "  /// Duration delay for the stream transformer.",
      "  final Duration duration;",
      "",
      "  @override",
      "  Stream<T> bind(Stream<T> stream) {",
      "    final controller = stream.isBroadcast",
      "        ? StreamController<T>.broadcast(sync: true)",
      "        : StreamController<T>(sync: true);",
      "    return (controller..onListen = () => _onListen(stream, controller)).stream;",
      "  }",
      "",
      "  void _onListen(",
      "    Stream<T> stream,",
      "    StreamController<T> controller,",
      "  ) {",
      "    final sink = controller.sink;",
      "    final subscription = stream.listen(null, cancelOnError: false);",
      "    controller.onCancel = subscription.cancel;",
      "    if (!stream.isBroadcast) {",
      "      controller",
      "        ..onPause = subscription.pause",
      "        ..onResume = subscription.resume;",
      "    }",
      "    final scaffold = _scaffold(sink, subscription.pause, subscription.resume);",
      "    subscription",
      "      ..onData(scaffold)",
      "      ..onError(sink.addError)",
      "      ..onDone(sink.close);",
      "  }",
      "",
      "  void Function(T data) _scaffold(",
      "    StreamSink<T> sink,",
      "    void Function([Future<void>? resumeSignal]) pause,",
      "    void Function() resume,",
      "  ) =>",
      "      (T data) {",
      "        ${0:// PUT YOUR CODE HERE}",
      "        try {",
      "          sink.add(data);",
      "        } on Object catch (error, stackTrace) {",
      "          sink.addError(error, stackTrace);",
      "        }",
      "        pause();",
      "        Timer(duration, resume);",
      "      };",
      "}\n"
    ]
  },
  "No Such Method": {
    "scope": "flutter, dart",
    "prefix": [
      "nosm",
      "noSuchMethod"
    ],
    "description": "This method is invoked when a non-existent method or property is accessed.",
    "body": [
      "@override",
      "dynamic noSuchMethod(Invocation invocation) {",
      "  ${1:}",
      "}"
    ]
  },
  "toString": {
    "scope": "flutter, dart",
    "prefix": "toString",
    "description": "Returns a string representation of this object.",
    "body": [
      "@override",
      "String toString() => ${1:Error.safeToString(this)};${0}"
    ]
  },
  "Test": {
    "scope": "flutter, dart",
    "prefix": [
      "test",
      "unitTest"
    ],
    "description": "Create a test function",
    "body": [
      "test('${1:test description}', () {",
      "  ${0:expect(true, isTrue);}",
      "});\n"
    ]
  },
  "Pragma": {
    "scope": "flutter, dart",
    "prefix": [
      "@pragma",
      "pragma"
    ],
    "description": "Pragma annotation https://mrale.ph/dartvm/pragmas.html",
    "body": "@pragma(${1|'vm:entry-point','vm:never-inline','vm:prefer-inline','dart2js:tryInline','vm:notify-debugger-on-exception','vm:invisible','vm:always-consider-inlining','flutter:keep-to-string','flutter:keep-to-string-in-subtypes'|})"
  },
  "Dart doc disable documentation": {
    "scope": "flutter, dart",
    "prefix": [
      "doc-disabled",
      "nodoc",
      "@nodoc",
      "@doc-disabled"
    ],
    "description": "No documentation annotation",
    "body": [
      "/// {@nodoc}"
    ]
  },
  "Dart doc category": {
    "scope": "flutter, dart",
    "prefix": [
      "category",
      "doc-category",
      "dartdoc-category",
      "@doc-category"
    ],
    "description": "Add category to documentation",
    "body": [
      "/// {@${1|category,subCategory|} ${0}}"
    ]
  },
  "Dart doc image": {
    "scope": "flutter, dart",
    "prefix": [
      "doc-image",
      "dartdoc-image",
      "@doc-image"
    ],
    "description": "Add image to documentation",
    "body": [
      "/// {@image <image alt='' src='${0:https://host.tld/path/to/image.png}'>}"
    ]
  },
  "Dart doc animation": {
    "scope": "flutter, dart",
    "prefix": [
      "doc-animation",
      "dartdoc-animation",
      "@doc-animation"
    ],
    "description": "Add animation to documentation",
    "body": "/// {@animation name 100 200 ${0:https://host.tld/path/to/video.mp4}}"
  },
  "Dartdoc new template": {
    "scope": "flutter, dart",
    "prefix": [
      "@template",
      "template",
      "dartdoc-new-template",
      "doc-new-macro",
      "newtmpl",
      "@doc-template"
    ],
    "description": "Creates a new dartdoc template with current file's name as its prefix",
    "body": [
      "/// {@template ${1:$TM_FILENAME_BASE}}",
      "/// ${0:Body of the template}",
      "/// {@endtemplate}"
    ]
  },
  "Dartdoc use macro": {
    "scope": "flutter, dart",
    "prefix": [
      "@macro",
      "macro",
      "dartdoc-use-template",
      "doc-use-macro",
      "usetmpl",
      "@doc-macro"
    ],
    "description": "Uses existing dartdoc macro with current file's name as its prefix",
    "body": "/// {@macro ${0:$TM_FILENAME_BASE}}"
  },
  "Dartdoc inject html": {
    "scope": "flutter, dart",
    "prefix": [
      "@inject-html",
      "inject-html",
      "dartdoc-html",
      "doc-html",
      "html",
      "@doc-html"
    ],
    "description": "Injects html into the current comment",
    "body": [
      "/// {@inject-html}",
      "/// ${0:<p>[The HTML to inject.]()</p>}",
      "/// {@end-inject-html}"
    ]
  },
  "Deprecated": {
    "scope": "flutter, dart",
    "prefix": [
      "@deprecated",
      "deprecated"
    ],
    "description": "Deprecated",
    "body": "@Deprecated('${0:Reason}')"
  },
  "Meta": {
    "scope": "flutter, dart",
    "prefix": [
      "@meta",
      "meta",
      "@annotation",
      "annotation"
    ],
    "description": "Meta annotation",
    "body": "@${1|immutable,useResult,internal,protected,literal,mustCallSuper,sealed,alwaysThrows,factory,visibleForOverriding,visibleForTesting,experimental,nonVirtual,doNotStore,optionalTypeArgs|}"
  },
  "Coverage": {
    "scope": "flutter, dart",
    "prefix": [
      "coverage"
    ],
    "description": "Coverage annotation",
    "body": "// coverage:${1|ignore-line,ignore-start,ignore-end,ignore-file|}"
  },
  "Logging": {
    "scope": "flutter, dart",
    "prefix": [
      "logging",
      "logger"
    ],
    "description": "Logging",
    "body": [
      "import 'dart:async';",
      "import 'dart:developer' as developer;",
      "",
      "/// Tracing information",
      "final void Function(Object? message) fine = _logAll('FINE', 500);",
      "",
      "/// Static configuration messages",
      "final void Function(Object? message) config = _logAll('CONF', 700);",
      "",
      "/// Iformational messages",
      "final void Function(Object? message) info = _logAll('INFO', 800);",
      "",
      "/// Potential problems",
      "final void Function(Object exception, [StackTrace? stackTrace, String? reason])",
      "    warning = _logAll('WARN', 900);",
      "",
      "/// Serious failures",
      "final void Function(Object error, [StackTrace stackTrace, String? reason])",
      "    severe = _logAll('ERR!', 1000);",
      "",
      "void Function(",
      "  Object? message, [",
      "  StackTrace? stackTrace,",
      "  String? reason,",
      "]) _logAll(String prefix, int level) =>",
      "    (Object? message, [StackTrace? stackTrace, String? reason]) {",
      "      //if (Zone.current[kLogEnabled] != true) return;",
      "      developer.log(",
      "        '[$prefix] ${reason ?? message}',",
      "        level: level,",
      "        name: 'main',",
      "        error: message is Exception || message is Error ? message : null,",
      "        stackTrace: stackTrace,",
      "      );",
      "    };",
      ""
    ]
  }
}
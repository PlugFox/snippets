{
    "Main entry point": {
        "scope": "flutter, dart",
        "prefix": "main",
        "description": "Main entry point",
        "body": [
            "import 'dart:async';\n",
            "@pragma('vm:entry-point')",
            "void main([List<String>? args]) => runZonedGuarded<Future<void>>(() async {",
            "      ${0:// ...}",
            "    }, (error, stackTrace) {",
            "      Error.safeToString(error);",
            "      stackTrace.toString();",
            "    });\n"
        ]
    },
    "Try-catch-finally block": {
        "scope": "flutter, dart",
        "prefix": "try",
        "description": "Try-catch-finally block",
        "body": [
            "try {",
            "  // ...",
            "} on Object catch (error, stackTrace) {",
            "  Error.safeToString(error);",
            "  stackTrace.toString();",
            "  rethrow;",
            "} finally {",
            "  // ...",
            "}"
        ]
    },
    "Timeout handler": {
        "scope": "flutter, dart",
        "prefix": "timeout",
        "description": "Timeout handler",
        "body": "timeout(const Duration(milliseconds: 5000))${0:;}"
    },
    "Catch Error handler": {
        "scope": "flutter, dart",
        "prefix": [
            "catchError",
            "onError"
        ],
        "description": "Catch Error handler",
        "body": [
            "catchError(",
            "  (Object error, StackTrace stackTrace) => print(",
            "    Error.safeToString(error),",
            "  ),",
            "  test: (error) => error is TimeoutException,",
            ")${0:;}"
        ]
    },
    "Flow & Timeline example": {
        "scope": "flutter, dart",
        "prefix": [
            "flow",
            "timeline"
        ],
        "description": "Flow & Timeline example",
        "body": [
            "final flow = Flow.begin();",
            "Timeline.startSync('name', flow: flow);",
            "Timeline.instantSync('name');",
            "Timeline.finishSync();",
            "Flow.step(flow.id);",
            "final result = Timeline.timeSync<T>('name', () => null, flow: flow);",
            "Flow.end(flow.id);"
        ],
    },
    "Relieve event-loop": {
        "scope": "flutter, dart",
        "prefix": [
            "relieve",
            "discharge"
        ],
        "description": "Relieve event-loop",
        "body": [
            "/// Allow relieve impact on event loop on large collections.",
            "/// Parallelize the event queue and free up time for processing animation,",
            "/// user gestures without using isolates.",
            "Stream<${2}> ${1:relieve}(Iterable<${2:T}> iterable) async* {",
            "  final flow = Flow.begin();",
            "  final sw = Stopwatch()..start();",
            "  try {",
            "    final iter = iterable.iterator;",
            "    var i = 0;",
            "    Timeline.startSync('${1}#\\$i', flow: flow);",
            "    while (iter.moveNext()) {",
            "      if (sw.elapsed > const Duration(milliseconds: 4)) {",
            "        Timeline.finishSync();",
            "        await Future<void>.delayed(Duration.zero);",
            "        sw.reset();",
            "        i++;",
            "        Timeline.startSync('${1}#\\$i', flow: flow);",
            "      }",
            "      ${0}",
            "      yield iter.current;",
            "      Flow.step(flow.id);",
            "    }",
            "    Timeline.finishSync();",
            "    Flow.end(flow.id);",
            "  } finally {",
            "    sw.stop();",
            "  }",
            "}\n"
        ],
    },
    "Platform conditional imports": {
        "scope": "flutter, dart",
        "prefix": [
            "conditional_imports",
            "import_conditional"
        ],
        "description": "Platform conditional imports",
        "body": [
            "import 'stub.dart'",
            "    // ignore: uri_does_not_exist",
            "    if (dart.library.html) 'web.dart'",
            "    // ignore: uri_does_not_exist",
            "    if (dart.library.io) 'io.dart';\n"
        ]
    },
    "Changelog unreleased": {
        "scope": "md, markdown",
        "prefix": "changelog_unreleased",
        "description": "Changelog unreleased",
        "body": [
            "# Unreleased",
            "+ added: ${0}",
            "+ changed: ",
            "+ deprecated: ",
            "+ removed: ",
            "+ fixed: ",
            "+ security: ",
            "+ refactor: ",
            "+ docs: ",
            "  "
        ]
    },
    "Changelog version": {
        "scope": "md, markdown",
        "prefix": "changelog_version",
        "description": "Changelog version section",
        "body": [
            "# ${1:0}.${2:0}.${3:0}",
            "+ added: ${0}",
            "+ changed: ",
            "+ deprecated: ",
            "+ removed: ",
            "+ fixed: ",
            "+ security: ",
            "+ refactor: ",
            "+ docs: ",
            "  "
        ]
    },
    "New dartdoc template": {
        "scope": "flutter, dart",
        "prefix": [
            "dartdoc_create_template",
            "new_dartdoc_template",
            "newtmpl",
        ],
        "description": "Creates a new dartdoc template with current file's name as its prefix",
        "body": [
          "/// {@template ${1}}",
          "/// $0",
          "/// {@endtemplate}"
        ]
    },
    "Dartdoc macro": {
        "scope": "flutter, dart",
        "prefix": [
            "dartdoc_use_template",
            "usetmpl"
        ],
        "description": "Uses existing dartdoc macro with current file's name as its prefix",
        "body": "/// {@macro $TM_FILENAME_BASE.$0}"
    },
    "Comment": {
        "scope": "flutter, dart",
        "prefix": [
            "cmnt",
            "comment"
        ],
        "description": "Comment block",
        "body": "// --- ${1} --- //\n\n$0"
    },
    "Divider": {
        "scope": "flutter, dart",
        "prefix": [
            "dvd",
            "divider_comment"
        ],
        "description": "Divider comment line",
        "body": "// --- ${1} --- //\n\n$0"
    },
    "Create new class": {
        "scope": "flutter, dart",
        "prefix": "class",
        "description": "Create new class",
        "body": [
            "/// {@template ${2:$TM_FILENAME_BASE}}",
            "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} class",
            "/// {@endtemplate}",
            "class ${1} {",
            "  /// {@macro ${2}}",
            "  const ${1}($0);",
            "  ",
            "} // ${1}\n"
        ]
    },
    "Data class": {
        "scope": "flutter, dart",
        "prefix": [
            "entity",
            "dataClass",
            "classData"
        ],
        "description": "Create new class",
        "body": [
            "import 'package:meta/meta.dart';\n\n",
            "/// {@template ${2:$TM_FILENAME_BASE}}",
            "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} entity",
            "/// {@endtemplate}",
            "@immutable",
            "// ignore: prefer_mixin",
            "class ${1} with Comparable<${1}> {",
            "  /// {@macro ${2}}",
            "  ${1}({",
            "    required this.id,",
            "    required this.title,",
            "    this.description = '',",
            "    DateTime? updated,",
            "    DateTime? created,",
            "  })  : updated = updated ?? DateTime.now(),",
            "        created = created ?? updated ?? DateTime.now();${0}",
            "",
            "  /// The unique identifier for this object.",
            "  final int id;",
            "",
            "  /// The title of this object.",
            "  final String title;",
            "",
            "  /// A short description of this object.",
            "  final String description;",
            "",
            "  /// The date this object was last updated.",
            "  final DateTime updated;",
            "",
            "  /// The date this object was created.",
            "  final DateTime created;",
            "",
            "  /// Generate Class from Map<String, Object?>",
            "  factory ${1}.fromJson(Map<String, Object?> json) => ${1}(",
            "        id: (json['id'] as int?)!,",
            "        title: (json['title'] as String?)!,",
            "        description: (json['description'] as String?)!,",
            "        updated: DateTime.parse((json['updated'] as String?)!).toLocal(),",
            "        created: DateTime.parse((json['created'] as String?)!).toLocal(),",
            "      );",
            "",
            "  /// Generate Map<String, Object?> from class",
            "  Map<String, Object?> toJson() => <String, Object?>{",
            "        'id': id,",
            "        'title': title,",
            "        'description': description,",
            "        'updated': updated.toUtc().toIso8601String(),",
            "        'created': created.toUtc().toIso8601String(),",
            "      };",
            "",
            "  /// Create a copy of this object with the given values.",
            "  ${1} copyWith({",
            "    int? newId,",
            "    String? newTitle,",
            "    String? newDescription,",
            "    DateTime? newUpdated,",
            "    DateTime? newCreated,",
            "  }) =>",
            "      ${1}(",
            "        id: newId ?? id,",
            "        title: newTitle ?? title,",
            "        description: newDescription ?? description,",
            "        updated: newUpdated ?? DateTime.now(),",
            "        created: newCreated ?? created,",
            "      );",
            "",
            "  @override",
            "  int compareTo(${1} other) => id.compareTo(other.id);",
            "",
            "  @override",
            "  int get hashCode => id;",
            "",
            "  @override",
            "  bool operator ==(Object other) =>",
            "      identical(this, other) ||",
            "      other is ${1} && runtimeType == other.runtimeType && id == other.id;",
            "",
            "  @override",
            "  String toString() => '${1}#\\$id';",
            "",
            "} // ${1}\n"
        ]
    },
    "Immutable collection data class": {
        "scope": "flutter, dart",
        "prefix": [
            "immutableCollection",
            "collectionDataClass"
        ],
        "description": "Immutable collection data class",
        "body": [
            "import 'dart:collection';\n",
            "import 'package:meta/meta.dart';\n\n",
            "/// {@template ${3:$TM_FILENAME_BASE}}",
            "/// ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} immutable collection.",
            "/// Creates an unmodifiable list backed by source.",
            "///",
            "/// The source of the elements may be a [List] or any [Iterable] with",
            "/// efficient [Iterable.length] and [Iterable.elementAt].",
            "/// {@endtemplate}",
            "@immutable",
            "class ${1} extends IterableBase<${2:T}> {",
            "  /// {@macro iterable.${3}}",
            "  ${1}(Iterable<${2}> source)",
            "      : _source = List<${2}>.of(source, growable: false);",
            "",
            "  /// {@macro iterable.${3}}",
            "  /// Empty collection",
            "  const ${1}.empty() : _source = const Iterable.empty();",
            "",
            "  final Iterable<${2}> _source;",
            "",
            "  @override",
            "  int get length => _source.length;",
            "",
            "  @override",
            "  ${2} get last => _source.last;",
            "",
            "  @override",
            "  Iterator<${2}> get iterator => _source.iterator;",
            "",
            "  /// Adds [value] to the end of this list,",
            "  /// Returns a new list with the element added.",
            "  ${1} add(${2} value) =>",
            "      ${1}(List<${2}>.of(_source)..add(value));",
            "",
            "  /// Appends all objects of [iterable] to the end of this list.",
            "  /// Returns a new list with the elements added.",
            "  ${1} addAll(Iterable<${2}> iterable) =>",
            "      ${1}(List<${2}>.of(_source)..addAll(iterable));",
            "",
            "  /// Removes the first occurrence of [value] from this list.",
            "  /// Returns a new list with removed element.",
            "  ${1} remove(${2} value) => ${1}(",
            "        List<${2}>.of(_source)..remove(value),",
            "      );",
            "",
            "  /// Removes all objects from this list that satisfy [test].",
            "  /// Returns a new list with removed element.",
            "  ${1} removeWhere(bool Function(${2}) test) => ${1}(",
            "        List<${2}>.of(_source)..removeWhere(test),",
            "      );",
            "",
            "  /// Set element.",
            "  /// Returns a new list with element.",
            "  ${1} upsert(${2} element) => ${1}(",
            "        List<${2}>.of(_source)",
            "          ..remove(element)",
            "          ..add(element),",
            "      );",
            "",
            "  /// Sorts this list according to the order specified by the [compare] function",
            "  ${1} sort([int Function(${2} a, ${2} b)? compare]) => ${1}(",
            "        List<${2}>.of(_source, growable: false)..sort(compare),",
            "      );",
            "",
            "  /// Generate Map<String, Object?> from class",
            "  List<Map<String, Object?>> toJson() =>",
            "    _source.map<Map<String, Object?>>((e) => e.toJson()).toList();",
            "",
            "  /// Returns the element at the given [index] in the list",
            "  ///  or throws an [RangeError]",
            "  ${2} operator [](int index) => _source.elementAt(index);",
            "} // ${1}\n"
        ]
    },
    "Reverse bypass": {
        "scope": "flutter, dart",
        "prefix": [
            "reverseList",
        ],
        "description": "Reverse list traversal in a loop",
        "body": [
            "final length = list.length;",
            "for (var i = 0; i < length; i++) {",
            "  final idx = length - i - 1;",
            "  if (list[idx].isOdd) {",
            "    list.removeAt(idx);",
            "  }",
            "}\n"
        ]
    },
    "Part": {
        "scope": "flutter, dart",
        "prefix": "part",
        "description": "Part of file",
        "body": [
            "part '${TM_FILENAME_BASE}.g.dart';$0"
        ]
    },
    "Mocks": {
        "scope": "flutter, dart",
        "prefix": "mocks",
        "description": "Import mocks file",
        "body": [
            "import '${TM_FILENAME_BASE}.mocks.dart';$0"
        ]
    },
    "Sign": {
        "scope": "flutter, dart",
        "prefix": "sign",
        "description": "Insert my sign",
        "body": [
            "${BLOCK_COMMENT_START}",
            " * $0",
            " * Matiunin Mikhail <plugfox@gmail.com>, ${CURRENT_DATE} ${CURRENT_MONTH_NAME} ${CURRENT_YEAR}",
            " ${BLOCK_COMMENT_END}"
        ]
    },
    "Dart Pad": {
        "scope": "flutter, dart",
        "prefix": [
            "pad",
            "dartPad",
        ],
        "description": "Insert my sign for dart pad",
        "body": [
            "${BLOCK_COMMENT_START}",
            " * $0",
            " * https://gist.github.com/PlugFox/${1}",
            " * https://dartpad.dev/${1}",
            " * Matiunin Mikhail <plugfox@gmail.com>, ${CURRENT_DATE} ${CURRENT_MONTH_NAME} ${CURRENT_YEAR}",
            " ${BLOCK_COMMENT_END}"
        ]
    },
    "ToDo": {
        "scope": "flutter, dart",
        "prefix": "todo",
        "description": "ToDo block",
        "body": [
            "${LINE_COMMENT} TODO: $0",
            "${LINE_COMMENT} Matiunin Mikhail <plugfox@gmail.com>, ${CURRENT_DATE} ${CURRENT_MONTH_NAME} ${CURRENT_YEAR}"
        ]
    },
    "Hash Code": {
        "scope": "flutter, dart",
        "prefix": [
            "hashCode",
            "equals",
            "=="
        ],
        "description": "Hash Code and Equals override",
        "body": [
            "@override",
            "int get hashCode => id.hashCode;\n",
            "@override",
            "bool operator ==(Object other) =>",
            "    identical(this, other) ||",
            "    other is ${1:${TM_FILENAME_BASE/(.)(.*)/${1:/upcase}${2:/camelcase}/}} &&",
            "        runtimeType == other.runtimeType &&",
            "        id == other.id;${0}\n"
        ]
    },
    "BLoC": {
        "scope": "flutter, dart",
        "prefix": "bloc",
        "description": "Buisness Logic Component",
        "body": [
            "import 'dart:async';\n",
            "import 'package:bloc/bloc.dart';",
            "import 'package:bloc_concurrency/bloc_concurrency.dart' as bloc_concurrency;",
            "import 'package:freezed_annotation/freezed_annotation.dart';",
            "import 'package:l/l.dart';\n",
            "part '${TM_FILENAME_BASE}.freezed.dart';\n",
            "/* ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}} Events */\n",
            "@freezed",
            "class ${1}Event with _$${1}Event {",
            "  const ${1}Event._();\n",
            "  const factory ${1}Event.create() = Create${1}Event;\n",
            "  const factory ${1}Event.read() = Read${1}Event;\n",
            "  const factory ${1}Event.update() = Update${1}Event;\n",
            "  const factory ${1}Event.delete() = Delete${1}Event;",
            "}\n",
            "/* ${1} States */\n",
            "@freezed",
            "class ${1}State with _$${1}State {",
            "  const ${1}State._();\n",
            "  /// Is in idle state",
            "  bool get idling => !isProcessing;\n",
            "  /// Is in progress state",
            "  bool get isProcessing => maybeMap<bool>(",
            "        orElse: () => true,",
            "        idle: (_) => false,",
            "      );\n",
            "  /// If an error has occurred",
            "  bool get hasError => maybeMap<bool>(orElse: () => false, error: (_) => true);\n",
            "  /// Idling state",
            "  const factory ${1}State.idle({",
            "    required final ${1}Entity data,",
            "    @Default('Idle') final String message,",
            "  }) = Idle${1}State;\n",
            "  /// Processing",
            "  const factory ${1}State.processing({",
            "    required final ${1}Entity data,",
            "    @Default('Processing') final String message,",
            "  }) = Processing${1}State;\n",
            "  /// Successful",
            "  const factory ${1}State.successful({",
            "    required final ${1}Entity data,",
            "    @Default('Successful') final String message,",
            "  }) = Successful${1}State;\n",
            "  /// An error has occurred",
            "  const factory ${1}State.error({",
            "    required final ${1}Entity data,",
            "    @Default('An error has occurred') final String message,",
            "  }) = Error${1}State;",
            "}\n",
            "/// Buisiness Logic Component ${1}BLoC",
            "class ${1}BLoC extends Bloc<${1}Event, ${1}State> implements EventSink<${1}Event> {",
            "  ${1}BLoC({",
            "    required final I${1}Repository repository,",
            "    final ${1}State? initialState,",
            "  }) : _repository = repository,",
            "        super(",
            "          initialState ??",
            "              ${1}State.idle(",
            "                data: ${1}Entity(),",
            "                message: 'Initial idle state',",
            "              ),",
            "        ) {",
            "    on<${1}Event>(",
            "      (event, emit) => event.map<Future<void>>(",
            "        create: (event) => _create(event, emit),",
            "        read: (event) => _read(event, emit),",
            "        update: (event) => _update(event, emit),",
            "        delete: (event) => _delete(event, emit),",
            "      ),",
            "      transformer: bloc_concurrency.sequential(),",
            "      //transformer: bloc_concurrency.restartable(),",
            "      //transformer: bloc_concurrency.droppable(),",
            "      //transformer: bloc_concurrency.concurrent(),",
            "    );$0",
            "  }",
            "  ",
            "  final I${1}Repository _repository;",
            "  ",
            "  /// Create event handler",
            "  Future<void> _create(Create${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(${1}State.processing(data: state.data));",
            "      //final newData = await _repository.();",
            "      emit(${1}State.successful(data: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(${1}State.error(data: state.data));",
            "      rethrow;",
            "    } finally {",
            "      emit(${1}State.idle(data: state.data));",
            "    }",
            "  }",
            "  ",
            "  /// Read event handler",
            "  Future<void> _read(Read${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(${1}State.processing(data: state.data));",
            "      //final newData = await _repository.();",
            "      emit(${1}State.successful(data: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(${1}State.error(data: state.data));",
            "      rethrow;",
            "    } finally {",
            "      emit(${1}State.idle(data: state.data));",
            "    }",
            "  }",
            "  ",
            "  /// Update event handler",
            "  Future<void> _update(Update${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(${1}State.processing(data: state.data));",
            "      //final newData = await _repository.();",
            "      emit(${1}State.successful(data: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(${1}State.error(data: state.data));",
            "      rethrow;",
            "    } finally {",
            "      emit(${1}State.idle(data: state.data));",
            "    }",
            "  }",
            "  ",
            "  /// Delete event handler",
            "  Future<void> _delete(Delete${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(${1}State.processing(data: state.data));",
            "      //final newData = await _repository.();",
            "      emit(${1}State.successful(data: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(${1}State.error(data: state.data));",
            "      rethrow;",
            "    } finally {",
            "      emit(${1}State.idle(data: state.data));",
            "    }",
            "  }",
            "}"
        ]
    },
    "BLoC Extended": {
        "scope": "flutter, dart",
        "prefix": "blocExtended",
        "description": "Buisness Logic Component with mixins",
        "body": [
            "import 'dart:async';\n",
            "import 'package:bloc/bloc.dart';",
            "import 'package:bloc_concurrency/bloc_concurrency.dart' as bloc_concurrency;",
            "import 'package:freezed_annotation/freezed_annotation.dart';",
            "import 'package:l/l.dart';\n",
            "part '${TM_FILENAME_BASE}.freezed.dart';\n",
            "/* ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}} Events */\n",
            "@freezed",
            "class ${1}Event with _$${1}Event {",
            "  const ${1}Event._();\n",
            "  @Implements<I${1}Event>()",
            "  @With<_ProcessingStateEmitter>()",
            "  @With<_SuccessfulStateEmitter>()",
            "  @With<_ErrorStateEmitter>()",
            "  @With<_IdleStateEmitter>()",
            "  const factory ${1}Event.create() = Create${1}Event;\n",
            "  @Implements<I${1}Event>()",
            "  @With<_ProcessingStateEmitter>()",
            "  @With<_SuccessfulStateEmitter>()",
            "  @With<_ErrorStateEmitter>()",
            "  @With<_IdleStateEmitter>()",
            "  const factory ${1}Event.read() = Read${1}Event;\n",
            "  @Implements<I${1}Event>()",
            "  @With<_ProcessingStateEmitter>()",
            "  @With<_SuccessfulStateEmitter>()",
            "  @With<_ErrorStateEmitter>()",
            "  @With<_IdleStateEmitter>()",
            "  const factory ${1}Event.update() = Update${1}Event;\n",
            "  @Implements<I${1}Event>()",
            "  @With<_ProcessingStateEmitter>()",
            "  @With<_SuccessfulStateEmitter>()",
            "  @With<_ErrorStateEmitter>()",
            "  @With<_IdleStateEmitter>()",
            "  const factory ${1}Event.delete() = Delete${1}Event;",
            "}\n",
            "/* ${1} States */\n",
            "@freezed",
            "class ${1}State with _$${1}State {",
            "  const ${1}State._();\n",
            "  /// Is in idle state",
            "  bool get idling => !isProcessing;\n",
            "  /// Is in progress state",
            "  bool get isProcessing => maybeMap<bool>(",
            "        orElse: () => true,",
            "        idle: (_) => false,",
            "      );\n",
            "  /// If an error has occurred",
            "  bool get hasError => maybeMap<bool>(orElse: () => false, error: (_) => true);\n",
            "  /// Idling state",
            "  const factory ${1}State.idle({",
            "    required final ${1}Entity data,",
            "    @Default('Idle') final String message,",
            "  }) = Idle${1}State;\n",
            "  /// Processing",
            "  const factory ${1}State.processing({",
            "    required final ${1}Entity data,",
            "    @Default('Processing') final String message,",
            "  }) = Processing${1}State;\n",
            "  /// Successful",
            "  const factory ${1}State.successful({",
            "    required final ${1}Entity data,",
            "    @Default('Successful') final String message,",
            "  }) = Successful${1}State;\n",
            "  /// An error has occurred",
            "  const factory ${1}State.error({",
            "    required final ${1}Entity data,",
            "    @Default('An error has occurred') final String message,",
            "  }) = Error${1}State;",
            "}\n",
            "/// Buisiness Logic Component ${1}BLoC",
            "class ${1}BLoC extends Bloc<${1}Event, ${1}State> implements EventSink<${1}Event> {",
            "  ${1}BLoC({",
            "    required final I${1}Repository repository,",
            "    final ${1}State? initialState,",
            "  }) : _repository = repository,",
            "        super(",
            "          initialState ??",
            "              ${1}State.idle(",
            "                data: ${1}Entity(),",
            "                message: 'Initial idle state',",
            "              ),",
            "        ) {",
            "    on<${1}Event>(",
            "      (event, emit) => event.map<Future<void>>(",
            "        create: (event) => _create(event, emit),",
            "        read: (event) => _read(event, emit),",
            "        update: (event) => _update(event, emit),",
            "        delete: (event) => _delete(event, emit),",
            "      ),",
            "      transformer: bloc_concurrency.sequential(),",
            "      //transformer: bloc_concurrency.restartable(),",
            "      //transformer: bloc_concurrency.droppable(),",
            "      //transformer: bloc_concurrency.concurrent(),",
            "    );$0",
            "  }",
            "  ",
            "  final I${1}Repository _repository;",
            "  ",
            "  /// Create event handler",
            "  Future<void> _create(Create${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(event.inProgress(state: state));",
            "      //final newData = await _repository.();",
            "      emit(event.successful(state: state, newData: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(event.error(state: state, message: 'An error occurred'));",
            "      rethrow;",
            "    } finally {",
            "      emit(event.idle(state: state));",
            "    }",
            "  }",
            "  ",
            "  /// Read event handler",
            "  Future<void> _read(Read${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(event.inProgress(state: state));",
            "      //final newData = await _repository.();",
            "      emit(event.successful(state: state, newData: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(event.error(state: state, message: 'An error occurred'));",
            "      rethrow;",
            "    } finally {",
            "      emit(event.idle(state: state));",
            "    }",
            "  }",
            "  ",
            "  /// Update event handler",
            "  Future<void> _update(Update${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(event.inProgress(state: state));",
            "      //final newData = await _repository.();",
            "      emit(event.successful(state: state, newData: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(event.error(state: state, message: 'An error occurred'));",
            "      rethrow;",
            "    } finally {",
            "      emit(event.idle(state: state));",
            "    }",
            "  }",
            "  ",
            "  /// Delete event handler",
            "  Future<void> _delete(Delete${1}Event event, Emitter<${1}State> emit) async {",
            "    try {",
            "      emit(event.inProgress(state: state));",
            "      //final newData = await _repository.();",
            "      emit(event.successful(state: state, newData: newData));",
            "    } on Object catch (err, stackTrace) {",
            "      l.e('В ${1}BLoC произошла ошибка: \\$err', stackTrace);",
            "      emit(event.error(state: state, message: 'An error occurred'));",
            "      rethrow;",
            "    } finally {",
            "      emit(event.idle(state: state));",
            "    }",
            "  }",
            "}",
            "",
            "/* Интерфейсы для эвентов ${1}Event */",
            "",
            "abstract class I${1}Event {}",
            "",
            "/* Миксины для эвентов ${1}Event */",
            "",
            "/// Создание состояний \"в обработке\"",
            "mixin _ProcessingStateEmitter on ${1}Event {",
            "  /// Создание состояния \"в обработке\"",
            "  ${1}State inProgress({",
            "    required final ${1}State state,",
            "    final String? message,",
            "  }) =>",
            "      ${1}State.processing(",
            "        data: state.data,",
            "        message: message ?? 'Processing',",
            "      );",
            "}",
            "",
            "/// Выпуск состояния успешной обработки",
            "mixin _SuccessfulStateEmitter on ${1}Event {",
            "  /// Выпуск состояния успешной обработки",
            "  ${1}State successful({",
            "    required final ${1}State state,",
            "    final ${1}Entity? newData,",
            "    final String? message,",
            "  }) =>",
            "      ${1}State.successful(",
            "        data: newData ?? state.data,",
            "        message: message ?? 'Successful',",
            "      );",
            "}",
            "",
            "/// Выпуск состояния ошибки",
            "mixin _ErrorStateEmitter on ${1}Event {",
            "  /// Произошла ошибка",
            "  ${1}State error({",
            "    required final ${1}State state,",
            "    final String? message,",
            "  }) =>",
            "      ${1}State.error(",
            "        data: state.data,",
            "        message: message ?? 'An error has occurred',",
            "      );",
            "}",
            "",
            "/// Состояние ожидания действий пользователя",
            "mixin _IdleStateEmitter on ${1}Event {",
            "  /// Состояние ожидания действий пользователя",
            "  /// Простаиваем до получения события",
            "  ${1}State idle({",
            "    required final ${1}State state,",
            "    final String? message,",
            "  }) =>",
            "      ${1}State.idle(",
            "        data: state.data,",
            "        message: message ?? 'Idle',",
            "      );",
            "}"
        ]
    },
    "BLoC Test": {
        "scope": "flutter, dart",
        "prefix": "blocTest",
        "description": "Buisness Logic Component Test",
        "body": [
            "blocTest<${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)(bloc)/${1:/upcase}${2:/camelcase}/g}}BLoC, ${1}State>(",
            "  '${1}BLoC',",
            "  setUp: () async {},",
            "  tearDown: null,",
            "  build: () => ${1}BLoC(),",
            "  seed: () => ${1}State.idle(),",
            "  act: (bloc) => bloc.add(${1}Event.event()),",
            "  wait: const Duration(milliseconds: 150),",
            "  skip: 0,",
            "  expect: () => <Object>[",
            "    ${1}State.processing(),",
            "    ${1}State.idle(),",
            "  ],",
            "  verify: null,",
            "  errors: null,",
            ");"
        ]
    },
    "Freezed": {
        "scope": "flutter, dart",
        "prefix": [
            "freezed",
            "freezed_v1"
        ],
        "description": "Freezed data class",
        "body": [
            "// ignore_for_file: invalid_annotation_target",
            "",
            "import 'package:freezed_annotation/freezed_annotation.dart';",
            "",
            "part '${TM_FILENAME_BASE}.freezed.dart';",
            "part '${TM_FILENAME_BASE}.g.dart';",
            "",
            "/// ${1} data class",
            "@Freezed(unionKey: 'type', unionValueCase: FreezedUnionCase.snake)",
            "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} with _$${1} {",
            "  const ${1}._();",
            "",
            "  /// Other${1}",
            "  @FreezedUnionValue('OTHER')",
            "  const factory ${1}.other({",
            "    @JsonKey(name: 'value', required: true, disallowNullValue: true)",
            "      required final String value,",
            "  }) = Other${1};",
            "  ${0}",
            "  /// Generate ${1} class from Map<String, Object?>",
            "  factory ${1}.fromJson(Map<String, Object?> json) => _$${1}FromJson(json);",
            "}"
        ]
    },
    "JSON": {
        "scope": "flutter, dart",
        "prefix": [
            "json",
            "fromJson",
            "toJson"
        ],
        "description": "Generate JSON",
        "body": [
            "/// Generate Class from Map<String, Object?>",
            "factory ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}}.fromJson(Map<String, Object?> json) => _$${1}FromJson(json);",
            "",
            "/// Generate Map<String, Object?> from class",
            "Map<String, Object?> toJson() => _$${1}ToJson(this);"
        ]
    },
    "Fake": {
        "scope": "flutter, dart",
        "prefix": "fake",
        "description": "Generate Fake class",
        "body": [
            "class Mock${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} extends Fake implements ${1} {}"
        ]
    },
    "Singleton": {
        "scope": "flutter, dart",
        "prefix": "singleton",
        "description": "Generate Fake class",
        "body": [
            "/// ${1} Singleton class",
            "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}} {",
            "  static final ${1} _internalSingleton = ${1}._internal();",
            "  factory ${1}() => _internalSingleton;",
            "  ${1}._internal();\n",
            "  ${0}",
            "}"
        ]
    },
    "StreamTransformer with handlers": {
        "scope": "flutter, dart",
        "prefix": [
            "transformer_handlers",
            "stream_transformer_handlers"
        ],
        "description": "StreamTransformer with handlers, convert types",
        "body": [
            "import 'dart:async';\n",
            "import 'package:meta/meta.dart';\n",
            "/// ${1} extension methods.",
            "/// sourceStream.${1/(.)(.*)/${1:/downcase}$2/g}<T>()",
            "extension ${1}X<Input> on Stream<Input> {",
            "  /// {@macro ${2}}",
            "  Stream<Output> ${1/(.)(.*)/${1:/downcase}$2/g}<Output>({",
            "    /// Handler for the stream data channel.",
            "    required FutureOr<void> Function(",
            "      Input data,",
            "      EventSink<Output> sink,",
            "    )",
            "        handleData,",
            "",
            "    /// Handler for the stream error channel.",
            "    FutureOr<void> Function(",
            "      Object error,",
            "      StackTrace stackTrace,",
            "      EventSink<Output> sink,",
            "    )?",
            "        handleError,",
            "",
            "    /// Handler for the stream close event.",
            "    FutureOr<void> Function(",
            "      EventSink<Output> sink,",
            "    )?",
            "        handleDone,",
            "}) =>",
            "    transform<Output>(",
            "        ${1}<Input, Output>(",
            "          handleData: handleData,",
            "          handleError: handleError,",
            "          handleDone: handleDone,",
            "        ),",
            "      );",
            "} // end of ${1}X extension\n",
            "/// {@template ${2:$TM_FILENAME_BASE}}",
            "/// ${1} stream transformer",
            "/// {@endtemplate}",
            "@immutable",
            "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}}<Input, Output>",
            "    extends StreamTransformerBase<Input, Output> {",
            "  /// {@macro ${2}}",
            "  const ${1}({",
            "    required this.handleData,",
            "    this.handleError,",
            "    this.handleDone,",
            "  });",
            "",
            "  final FutureOr<void> Function(",
            "    Input data,",
            "    EventSink<Output> sink,",
            "  ) handleData;",
            "",
            "  final FutureOr<void> Function(",
            "    Object error,",
            "    StackTrace stackTrace,",
            "    EventSink<Output> sink,",
            "  )? handleError;",
            "",
            "  final FutureOr<void> Function(EventSink<Output> sink)? handleDone;",
            "",
            "  @override",
            "  Stream<Output> bind(Stream<Input> stream) {",
            "    final controller = stream.isBroadcast",
            "        ? StreamController<Output>.broadcast(sync: true)",
            "        : StreamController<Output>(sync: true);",
            "    return (controller..onListen = () => _onListen(stream, controller)).stream;",
            "  }",
            "",
            "  void _onListen(",
            "    Stream<Input> stream,",
            "    StreamController<Output> controller,",
            "  ) {",
            "    final sink = controller.sink;",
            "    final subscription = stream.listen(null, cancelOnError: false);",
            "    controller.onCancel = subscription.cancel;",
            "    if (!stream.isBroadcast) {",
            "      controller",
            "        ..onPause = subscription.pause",
            "        ..onResume = subscription.resume;",
            "    }",
            "    final scaffold = _scaffold(sink, subscription.pause, subscription.resume);",
            "    subscription",
            "      ..onData(",
            "        (Input data) => scaffold(() => handleData(data, sink)),",
            "      )",
            "      ..onError(",
            "        (Object error, StackTrace stackTrace) => handleError == null",
            "            ? sink.addError(error, stackTrace)",
            "            : scaffold(() => handleError!(error, stackTrace, sink)),",
            "      )",
            "      ..onDone(",
            "        () => handleDone == null",
            "            ? sink.close()",
            "            : scaffold(() => handleDone!(sink)).whenComplete(sink.close),",
            "      );",
            "  }",
            "",
            "  Future<void> Function(FutureOr<void> Function() handler) _scaffold(",
            "    StreamSink<Output> sink,",
            "    void Function([Future<void>? resumeSignal]) pause,",
            "    void Function() resume,",
            "  ) =>",
            "      (FutureOr<void> Function() handler) {",
            "        ${0:// PUT YOUR CODE HERE}",
            "        FutureOr<void> fn;",
            "        try {",
            "          fn = handler();",
            "        } on Object catch (error, stackTrace) {",
            "          sink.addError(error, stackTrace);",
            "        }",
            "        if (fn is Future) {",
            "          pause();",
            "          return fn.catchError(sink.addError).whenComplete(resume);",
            "        } else {",
            "          return Future<void>.value();",
            "        }",
            "      };",
            "} // end of ${1}\n"
        ]
    },
    "StreamTransformer with control queue delay": {
        "scope": "flutter, dart",
        "prefix": [
            "transformer_delay",
            "stream_transformer_delay"
        ],
        "description": "StreamTransformer with control queue delay",
        "body": [
            "import 'dart:async';\n",
            "import 'package:meta/meta.dart';\n",
            "/// ${1} extension methods.",
            "/// sourceStream.${1/(.)(.*)/${1:/downcase}$2/g}<T>()",
            "extension ${1}X<T> on Stream<T> {",
            "  /// {@macro ${2}}",
            "  Stream<T> ${1/(.)(.*)/${1:/downcase}$2/g}(Duration duration) =>",
            "      transform<T>(${1}<T>(duration));",
            "} // end of ${1}X extension\n",
            "/// {@template ${2:$TM_FILENAME_BASE}}",
            "/// ${1} stream transformer",
            "/// {@endtemplate}",
            "@immutable",
            "class ${1:${TM_FILENAME_BASE/(^[a-zA-Z]{1})(.*)/${1:/upcase}${2:/camelcase}/g}}<T>",
            "    extends StreamTransformerBase<T, T> {",
            "  /// {@macro ${2}}",
            "  const ${1}(this.duration);",
            "",
            "  /// Duration delay for the stream transformer.",
            "  final Duration duration;",
            "",
            "  @override",
            "  Stream<T> bind(Stream<T> stream) {",
            "    final controller = stream.isBroadcast",
            "        ? StreamController<T>.broadcast(sync: true)",
            "        : StreamController<T>(sync: true);",
            "    return (controller..onListen = () => _onListen(stream, controller)).stream;",
            "  }",
            "",
            "  void _onListen(",
            "    Stream<T> stream,",
            "    StreamController<T> controller,",
            "  ) {",
            "    final sink = controller.sink;",
            "    final subscription = stream.listen(null, cancelOnError: false);",
            "    controller.onCancel = subscription.cancel;",
            "    if (!stream.isBroadcast) {",
            "      controller",
            "        ..onPause = subscription.pause",
            "        ..onResume = subscription.resume;",
            "    }",
            "    final scaffold = _scaffold(sink, subscription.pause, subscription.resume);",
            "    subscription",
            "      ..onData(scaffold)",
            "      ..onError(sink.addError)",
            "      ..onDone(sink.close);",
            "  }",
            "",
            "  void Function(T data) _scaffold(",
            "    StreamSink<T> sink,",
            "    void Function([Future<void>? resumeSignal]) pause,",
            "    void Function() resume,",
            "  ) =>",
            "      (T data) {",
            "        ${0:// PUT YOUR CODE HERE}",
            "        try {",
            "          sink.add(data);",
            "        } on Object catch (error, stackTrace) {",
            "          sink.addError(error, stackTrace);",
            "        }",
            "        pause();",
            "        Timer(duration, resume);",
            "      };",
            "} // end of ${1}\n"
        ]
    },
    "MIT License": {
        "scope": "flutter, dart",
        "prefix": [
            "mit",
            "license"
        ],
        "description": "MIT License",
        "body": [
            "/*",
            " * MIT License",
            " *",
            " * Copyright (c) ${CURRENT_YEAR} Matiunin Mikhail <plugfox@gmail.com>",
            " *",
            " * Permission is hereby granted, free of charge, to any person obtaining a copy",
            " * of this software and associated documentation files (the \"Software\"), to deal",
            " * in the Software without restriction, including without limitation the rights",
            " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
            " * copies of the Software, and to permit persons to whom the Software is",
            " * furnished to do so, subject to the following conditions:",
            " *",
            " * The above copyright notice and this permission notice shall be included in",
            " * all copies or substantial portions of the Software.",
            " * ",
            " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
            " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
            " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
            " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
            " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
            " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
            " * SOFTWARE.",
            " */\n"
        ]
    },
    "No Such Method": {
        "scope": "flutter, dart",
        "prefix": [
            "nosm",
            "noSuchMethod"
        ],
        "description": "This method is invoked when a non-existent method or property is accessed.",
        "body": [
            "@override",
            "dynamic noSuchMethod(Invocation invocation) {",
            "  ${1:}",
            "}"
        ]
    },
    "toString": {
        "scope": "flutter, dart",
        "prefix": "toString",
        "description": "Returns a string representation of this object.",
        "body": [
            "@override",
            "String toString() => ${1:Error.safeToString(this)};${0}"
        ]
    },
    "Test": {
        "scope": "flutter, dart",
        "prefix": [
            "test",
            "unitTest"
        ],
        "description": "Create a test function",
        "body": [
            "test('${1:test description}', () {",
            "  ${0:expect(true, isTrue);}",
            "});\n",
        ]
    }
}